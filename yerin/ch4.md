## 리액트 코딩은 결국 컴포넌트 작성이다

#### 가독성과 생산성을 고려한 컴포넌트 코드 작성법

**-추천**

* 코드를 그룹으로 나누고 우선순위에 따라 배치하기
  * 속성값의 타입
  * state
  * 리액트 생명 주기 메서드
  * render를 제외한 나머지 메서드
  * render 내부에 사용할 속성값과 상태값
  * 외부변수(render가 호출될때마다 선언되기때문에 밖에서 선언이 성능에 좋음)
* 함수형 컴포넌트
  * 속성값 타입 정의
  * 명명된 매개변수로 컴포넌트 작성
  * 컴포넌트에서 사용되는 변수와 함수 작성
  * 컴포넌트를 외부로 내보내는 코드 작성



**-prop-types**

속성값의 type를 정의할 수 있음

함수의 매개변수와 반환값은 정의할 수 없음

커스텀도 가능



**-가독성을 높이는 조건부 렌더링**

* 삼항 연산자보다 && 연산자
  * 가독성이 더 좋음
  * null을 생략할 수 있음
  * 주의할 점 - 0과 ""은 false로 처리된다
    * 해결 -> (변수) != null && 로 처리한다



**-관심사 분리를 위한 프레젠테이션, 컨테이너 컴포넌트 구분하기**

* 프레젠테이션 컴포넌트
  * ui를 담고있음
  * 보통 함수형으로 작성됨
  * 상태값이 업다
* 컨테이너 컴포넌트
  * 비즈니스 로직을 담고있음
  * 상태값을 가지고있음





#### 이벤트 처리 함수 작성하기

* 클래스 필드를 이용해 이벤트 처리 메서드 작성하기

  * render에서 함수를 바인딩할경우 render메서드가 실행될때마다 새로운 함수가 생성되기 때문에 성능에 영향을 미친다.
  * 요즘은 브라우저가 좋아져서 그렇게 성능에 영향을 미치지 않아 훅도 render내의 함수생성을 매우 적극적으로 이용한다함,
  * 바인딩이 귀찮다면 화살표 함수로~~

* 데이터 세트로 이벤트 처리 함수에 값 전달하기

  * 돔 요소에 data-로 시작하는 속성값을 입력하고

  * dataset 속성을 통해 가져온다

  * 대문자는 단어사이에 -를 넣는다

  * ```html + json
    <div data-your-name="yerin" data-my-favorite-drink="coffee"/>
    
    const yourName = e.currentTarget.dataset.yourName;
    const myFavoriteDrink = e.currentTarget.dataset.myFavoriteDrink
    ```

* 상탯값 올림으로 부모 컴포넌트의 상탯값 변경하기

  ->부모컴포넌트에서 이벤트 처리 함수를 자식컴포넌트에 전달해준다

* 부모 컴포넌트에서 자식 컴포넌트의 상태값을 변경하고 싶다면 ref를 이용

  * ref 속성값으로 자식 컴포넌트의 인스턴스에 접근하는 방식은 자식 컴포넌트가 클래스 컴포넌트인 경우에만 가능하다.

  * child컴포넌트의 내부에 의존성이 생기므로 꼭 필요한 경우에만 사용하자





#### 컴포넌트의 공통 기능 관리하기

* 고차 컴포넌트는 리액트 컴포넌트를 인자로 받아서 다른 리액트 컴포넌트를 반환하는 함수이다
* 기능을 재활용하고 컴포넌트 상태나 생애주기 관리를 추상화할 수 있다.

* 고차 컴포넌트를 이용한 공통 기능 관리
  * 고차 컴포넌트로 생명 주기 메서드는 건들지 말자
  * recompose사용하기
  * 정적매서드는 출력되는 컴포넌트에 전달되지 않으므로 hoist-non-react-statics패키지를 사용하여 정적 메서드를 연결해준다.

* 함수형 프로그래밍의 지식이 매우 필요할거같음

* spring으로 따지면 aop같은 개념..?

* [믹스인 이야기가 나오면서 해결책으로 HOC를 언급하는 글](https://itmining.tistory.com/124)

  



#### 렌더링 속도를 올리기 위한 성능 최적화 방법

* 랜더가 되는 시기 : 속성값과 상탯값이 변할 때

* 성능 최적화를 먼저 고민하기 보다는 어쩌다 한번 성능 이슈가 생겼을 때 고민해도 늦지 않는다.

* 최적화 방법

  * 상탯값을 불변 객체로 관리하기

    * 그냥 배열에 값을 추가하게되면 shouldComponentUpdate에서 배열의 속성값 하나하나 비교해줘야함
    * 그냥 객체를 비교연산 하나로 비교하고 싶으면 불변객체로 새로 만들어 관리하면됨 그 방법으로는 [링크 참고]([https://medium.com/@ljs0705/react-state%EA%B0%80-%EB%B6%88%EB%B3%80%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-ec2bf09c1021](https://medium.com/@ljs0705/react-state가-불변이어야-하는-이유-ec2bf09c1021))
    * [퓨어컴포넌트 memo에 관한 글](https://engineering.huiseoul.com/react-16-6-new-features-memo-lazy-etc-452c78ace739)

  * 렌더 함수에서 새로운 객체 만들지 않기

    랜더가 실행될때마다 객체가 생성되기 때문

  * 메모이제이션 이용하기

    lodash/memoize이용

    메모이제이션은 단순 비교를 하기 때문에 불변객체로 관리해야함

  * 성능 최적화를 위한 도구들 이용하기

    * highlight updates옵션
    * 크롬의 performance
    * User Timing Api